# 芯片指令延迟测试方案

## 一、测试目标
测试 x64、ARM、RISC-V 架构下 CPU 指令的延迟（Latency）和吞吐（Throughput）

## 二、核心概念

### 指令延迟 (Latency)
- 单条指令从开始执行到产生结果所需的时钟周期数
- 例如：整数加法通常 1 周期，乘法 3-5 周期

### 指令吞吐 (Throughput)
- 流水线稳定状态下，每周期能执行的指令数
- 倒数即为执行 N 条指令所需周期数

---

## 三、技术难点与要点

| 难点 | 说明 | 解决方案 |
|------|------|----------|
| **CPU 指令缓存** | 首次执行慢，后续从缓存取快 | 预热 + 多次测量 |
| **分支预测** | 条件跳转影响流水线 | 使用无分支代码或预测成功的分支 |
| **指令重排** | CPU 动态调整指令顺序 | 使用 `lfence` / `cpuid` 串行化 |
| **动态频率** | 现代 CPU 睿频/降频 | 锁定频率或使用平均时间 |
| **内存访问延迟** | 加载/存储受内存影响 | 使用寄存器-only 指令 |
| **跨架构差异** | x86/ARM/RISC-V 指令集不同 | 分别为每种架构编写测试代码 |

---

## 四、测试方法

### 1. 使用 CPU 内部计数器

**x86 (RDTSC)**
```asm
rdtsc          ; EAX = TSC 低32位, EDX = TSC 高32位
mov ebx, eax   ; 保存低32位
; 执行被测指令
rdtsc
sub eax, ebx   ; 计算差值
```

**ARM (CNTVCT)**
```asm
mrs x0, cntvct_el0  ; 获取虚拟计数器
; 执行被测指令
mrs x1, cntvct_el0
sub x0, x1, x0
```

**RISC-V (cycle CSR)**
```cs
csrr t0, cycle
; 执行被测指令
csrr t1, cycle
sub t2, t1, t0
```

### 2. C/C++ 内联汇编测试框架

```c
#include <stdint.h>
#include <stdio.h>

// x86 RDTSC 读取
static inline uint64_t read_tsc(void) {
    unsigned int lo, hi;
    __asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi));
    return ((uint64_t)hi << 32) | lo;
}

// 禁止编译优化
#define NOOPT __attribute__((optimize("O0")))

// 测试单条指令延迟
#define TEST_LATENCY(insn, iter) do { \
    uint64_t start, end; \
    start = read_tsc(); \
    for (int i = 0; i < iter; i++) { \
        __asm__ volatile (insn); \
    } \
    end = read_tsc(); \
    printf(#insn ": %llu cycles\n", (end - start) / iter); \
} while(0)

int main() {
    TEST_LATENCY("nop", 1000000);
    TEST_LATENCY("add %eax, %eax", 1000000);
    TEST_LATENCY("imul %eax, %eax", 1000000);
    return 0;
}
```

---

## 五、推荐测试指令集

### 整数运算
| 指令 | x86 延迟 | ARM (ARM64) | RISC-V |
|------|----------|--------------|--------|
| ADD/SUB | 1 | 1 | 1 |
| MUL | 3-4 | 2-4 | 3-5 |
| DIV | 20-80 | 4-40 | 3-60 |

### 内存访问
| 指令 | x86 延迟 | 说明 |
|------|----------|------|
| LOAD (L1) | 4 | 命中L1缓存 |
| LOAD (L2) | 12 | 命中L2缓存 |
| LOAD (RAM) | 50-200 | 访问内存 |

---

## 六、Python 测试脚本 (调用外部程序)

```python
#!/usr/bin/env python3
import subprocess
import re
import statistics

def run_latency_test(binary_path: str, instruction: str, iterations: int = 1000000) -> dict:
    """运行指令延迟测试并解析结果"""
    result = subprocess.run(
        [binary_path, instruction, str(iterations)],
        capture_output=True,
        text=True
    )
    
    # 解析输出 (需要 C 代码配合输出格式)
    match = re.search(r'(\d+\.?\d*)\s+cycles', result.stdout)
    if match:
        return {"latency": float(match.group(1))}
    return {}

# 使用示例
results = {
    "x86": {},
    "arm": {},
    "riscv": {}
}

# 在各平台编译后测试
# results["x86"]["add"] = run_latency_test("./latency_test_x86", "add")
```

---

## 七、执行计划 (Plan)

- [ ] **阶段1**: 编写 C 语言测试框架，支持 x86/ARM/RISC-V
- [ ] **阶段2**: 实现基础指令测试 (算术、逻辑、位移)
- [ ] **阶段3**: 添加内存访问延迟测试
- [ ] **阶段4**: 实现多平台交叉编译脚本
- [ ] **阶段5**: 生成对比报告 (Markdown/CSV)

---

## 八、需要的工具

- GCC/Clang 编译器
- QEMU (模拟 ARM/RISC-V)
- objdump / objconv (反汇编)
- Linux perf (可选)

---

需要我帮你编写具体的 C 测试代码吗？可以指定具体架构。
