# x64 指令延迟测试框架

## 编译运行

```bash
gcc -O0 -o latency_test_x64 latency_test_x64.c -lm
./latency_test_x64 [迭代次数] [测试次数]
```

## 参数

- `迭代次数`: 每次测试的循环次数 (默认 1000000)
- `测试次数`: 取平均的测试次数 (默认 3)

## 输出示例

```
============================================================
           x64 指令延迟测试框架 v2.0
============================================================
  编译: gcc -O0 -o latency_test_x64 latency_test_x64.c -lm
  运行: ./latency_test_x64 [迭代次数] [测试次数]
============================================================

参数: 迭代=1000000, 测试次数=3, 容差=50%

指令     类别   预期   实测   结果
------------------------------------------------------------
NOP        基础   1.00     1.07     [PASS]
ADD        算术   1.00     0.82     [PASS]
SUB        算术   1.00     0.83     [PASS]
...
============================================================
结果: 10/13 通过 (76.9%)
```

## 添加新指令

在代码中找到 `/* 在这里添加新指令测试 */` 部分，使用宏添加：

```c
TEST_INSN(指令名, "类别", 预期cycles, "汇编指令")
```

然后在 `init_tests()` 中注册：

```c
register_test("指令名", "类别", 预期值, test_函数名);
```

**示例：添加 ROL 指令**
```c
TEST_INSN(rol, "位移", 1.0, "rol $1, %eax")
// ...
register_test("ROL", "位移", 1.0, test_rol);
```

## 当前支持的指令

| 类别 | 指令 |
|------|------|
| 基础 | NOP |
| 算术 | ADD, SUB |
| 逻辑 | XOR, AND, OR, NOT |
| 乘除 | IMUL |
| 位移 | SHL, SHR |
| 移动 | MOV |
| 比较 | CMP, TEST |

## 注意事项

- WSL/虚拟化环境下部分指令测量可能不准确
- 某些指令 (如 PUSH/POP) 在用户态可能崩溃
- 建议在真实硬件上运行以获得准确数据
