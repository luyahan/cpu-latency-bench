# 指令延迟测试方案

## 一、常见测试方法

### 1. 时间戳对比法
- 在发送指令前记录时间戳 T1
- 收到响应后记录时间戳 T2
- 延迟 = T2 - T1

### 2. PING/PONG 机制
- 客户端发送带时间戳的 ping
- 服务器返回 pong
- 客户端计算往返时间 (RTT)

### 3. 多次测量取平均值
- 单次测量存在波动
- 建议测量 N 次 (如 10-100 次)
- 计算平均值、中位数、百分位数

---

## 二、技术难点要点

| 难点 | 说明 | 解决方案 |
|------|------|----------|
| **时钟同步** | 客户端与服务端时钟不同步 | 使用 NTP 同步或往返测量 |
| **网络波动** | 网络延迟不稳定 | 多次测量，去除异常值 |
| **系统调度延迟** | 进程调度引入误差 | 高优先级线程/实时系统 |
| **启动延迟** | 首次调用有冷启动时间 | 预热后再测量 |
| **资源竞争** | 多任务下的测量干扰 | 隔离测试环境 |

---

## 三、代码实现思路

### Python 示例 (通用框架)

```python
import time
import statistics
from typing import Callable, List

class LatencyTester:
    def __init__(self, warmup: int = 3, runs: int = 100):
        self.warmup = warmup
        self.runs = runs
        self.results: List[float] = []
    
    def measure(self, func: Callable, *args, **kwargs) -> dict:
        # 预热
        for _ in range(self.warmup):
            func(*args, **kwargs)
        
        # 正式测量
        self.results = []
        for _ in range(self.runs):
            start = time.perf_counter()
            func(*args, **kwargs)
            end = time.perf_counter()
            self.results.append((end - start) * 1000)  # 转换为毫秒
        
        return self._analyze()
    
    def _analyze(self) -> dict:
        return {
            "runs": self.runs,
            "min_ms": min(self.results),
            "max_ms": max(self.results),
            "avg_ms": statistics.mean(self.results),
            "median_ms": statistics.median(self.results),
            "p95_ms": statistics.quantiles(self.results, n=20)[18] if len(self.results) >= 20 else max(self.results),
        }

# 使用示例
tester = LatencyTester(warmup=3, runs=50)

# 测试函数延迟
result = tester.measure(lambda: sum(range(10000)))
print(result)
```

---

## 四、待细化内容

- [ ] 确认具体测试场景
- [ ] 选择编程语言
- [ ] 设计输出格式 (JSON/CSV/报告)
- [ ] 添加自动化测试脚本
